프로그램 이름 : loader 또는 pager
궁극의 목적 : argument로 file name을 받아 memory에 load 하고 execute
미리 공부해야 할 것 : 
    1-1. reading the code that implements the execve system call in the Linux kernel
    1-2. describe in pseudo-code the steps that occur in creating the memory image of a new process.
        (Focus on how the user-space memory is set up rather than how kernel data structures are modified.)
        (Pay attention to load_elf_binary.)

    2. Documentation for gcc and the linker (ld) will instruct you on 
    how to statically link and how to change the placement of your code. 

    3. Read the man page for the readelf and/or objdump utilities and try them
    out on some binaries.

    4. 

주의점
    1. your user-level program is different from the execve code
    (Your loader will load the program image into its own address space 
    and execute it from within its own address space.)
    (execve code is building a program to execute in a newly created address space)

    2. Make sure you map the sections from the file at the memory addresses
    specified in the ELF headers. You should treat the addresses in the
    headers as absolute addresses.

    3. Some sections of an executable are not backed with file contents, so
    they will take up more space in memory than they do in the file (ex:
    BSS). Make sure that for the first part of the lab, you map the entirety of
    each section, not just the part backed by the file.


구체적 실행과정
    1. load the program image into its own address space and execute it from within its own address space.
    1-1. load the elf file
    1-2. build the stack

    2. transfers control to the entry point of the loaded program via a jmp instruction.
    (you do not call the loaded program's main function, you jump to the entry point.)
    2-1. use inline assembly to clean up register state and transfer control to the entry point.

    3. you can statically link your loader program.
    You should also statically link the program under test. (These are two separate programs). 
    (I'd suggest linking each into disjoint address regions, and I'd suggest placing your loader program 
    into a region that is currently unused by system libraries.)

시작점(apager)(all-at-once)
    1. have your loader map the entire program (with the proper permissions).
    2. Map an anonymous region for the program's bss.
    3. Write at least two test programs that your loader will load and execute.
    4. Measure the execution time and memory use of these programs when they are run by your loader.
    5. Describe what functionality of your loader your test programs exercise.

시작점(dpager)(demand paging)
    1. only map a single page of the executable under test.
    2. Set up signal handlers to catch segmentation violations and any other signal you need.
    3. In the signal handler, determine what address your executable is trying to access, and map only that page
    4. Run the same tests on you demand paged loader as your all-at-once loader
    5. Demonstrate at least one program that runs faster for the all-at-once
    loader, and one that uses less memory for the demand paging loader.
    6. Present your findings.
    7. Implement and describe a method for your demand pager to preserve
    memory access errors present in the program under test. (null pointer error..)

시작점(hpager)(hybrid) :
    maps all text and initialized data at program startup, but maps all bss memory on demand.

    1. for every fault, you may map 2 pages, the demand page and another page. 
    2. Implement a prediction algorithm that choses the second page
    3. Find a workload that runs faster with your prediction algorithm than
    without and explain why.
    4. Also map 3 pages according to some heuristic and compare that to whatever is most illuminating.
    5. Please report how much time you spent on the lab.

힌트
    1. 